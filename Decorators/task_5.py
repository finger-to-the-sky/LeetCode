# Задача 1
#
# 1.1 Написать декоратор, который перед запуском произвольной функции с произвольным набором аргументов будет показывать
# в консоли сообщение "Покупайте наших котиков!" и возвращать результат запущенной функции. 1.2 Параметризовать декоратор
# таким образом, чтобы сообщение, печатаемое перед выполнением функции можно было задавать как параметр во время
# декорирования.


def message(mes):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(mes)

            return func(*args, **kwargs)
        return wrapper
    return decorator


# Задача 2
#
# 2.1 Написать декоратор, который внутри себя выполнял бы функцию и возвращал бы результат её работы в случае успешного
# выполнения. В случае возникновения ошибки во время выполнения функции нужно сделать так, чтобы выполнение функции было
# повторено ещё раз с теми же самыми аргументами, но не более 10 раз. Если после последней попытки функцию так и не
# удастся выполнить успешно, то бросать исключение. 2.2 Параметризовать декоратор таким образом, чтобы количество попыток
# выполнения функции можно было задавать как параметр во время декорирования.
#

def error_check(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            count = n
            while count != 0:
                try:
                    return func(*args, **kwargs)

                except Exception:
                    print(f'Ошибка аргументов функции! {args}')
                    count = count - 1
        return wrapper
    return decorator

# 3.1 Написать кэширующий декоратор. Суть в том, что если декорируемая функция будет запущена с теми параметрами с
# которыми она уже запускалась - брать результат из кэша и не производить повторное выполнение функции. 3.2 Сделать так,
# чтобы информация в кэше была актуальной не более 10 секунд. Предусмотреть механизм автоматической очистки кэша в
# процессе выполнения функций. 3.3 Параметризовать время кэширования в декораторе.
#
import time


def cash(n):
    def decorator(func):
        ls = []
        def wrapper(*args, **kwargs):
            f = func(*args, **kwargs)

            if f in ls:
                f = ls[ls.index(f)]
            else:
                ls.append(f)

            if time.sleep(n):
                ls.clear()

            return f
        return wrapper
    return decorator


# Задача 4
#
# 4.1 Написать декоратор, который бы измерял время работы функции и печатал бы его на экран. 4.2 Доработать декоратор
# таким образом, чтобы в логах было название запускаемой функции помимо времени исполнения. 4.3 Доработать декоратор так,
# чтобы запись лога для функции велась в файл, путь к которому нужно было бы задавать во время декорирования, как параметр.
#




def file_logs_time(path):
    def time_fiction(func):
        def wrapper(*args, **kwargs):

            start = time.time()
            f = func(*args, **kwargs)
            end = time.time() - start
            print(f'Функция {func} выполнилась за {end}')

            with open(path, 'a', encoding='UTF-8') as file:
                file.write(f'Функция {func} выполнилась за {end}\n')

            return f
        return wrapper
    return time_fiction

# Задача 5
#
# После решения задач написать функцию и задекорировать её сразу несколькими из созданных декораторов и посмотреть на
# результат и суметь объяснить его. Потом поменять порядок декорирования и проделать то же самое.




@message('Buy ours cats!')
@error_check(2)
@cash(1)
@file_logs_time('/home/zagmak/PycharmProjects/pythonProject/logs_2.txt')
def numbs_1(a, b):
    return a + b

print(numbs_1(2, 2))

# Сначала выводится сообщение, так как оно задано перед выполнением функции. Потом срабатывает запись работы в файл,
# после срабатывает кеш(выполняется задержка в 1 сек) и потом проверка на ошибки.
# Декораторы работаю снизу вверх. Так как сообщение перед выполнением функции то оно выполняется первым. После
# выполняется file_logs_time и передает обработанную func в cash. Затем cash обрабатывает ее и передает в error_check
# Там же идет обработка ошибок. Так как их нет, то обернутую всеми декораторами функцию он возвращает к вызову numbs.
#



@message('Buy ours cats!')
@error_check(2)
@cash(1)
@file_logs_time('/home/zagmak/PycharmProjects/pythonProject/logs_2.txt')
def numbs_2(a, b):
    return a + b

print(numbs_2(2, 2))

# Здесь работа осуществялется следующим образом. Срабатывает message. Затем проводят свою работу file_logs_time и cash и
# передают обработанную функцию но срабатывает обработка ошибок. После запускается цикл и выводится сообщение из
# Exception и запускает обработку столько раз сколько указанно в декораторе. Так в обработке, при случае не правильно
# указанных параметров нет return, а тольк1о print, то декораторы не возвращают нашу функцию.

@file_logs_time('/home/zagmak/PycharmProjects/pythonProject/logs_2.txt')
@message('Buy ours cats!')
@error_check(2)
@cash(1)
def numbs_3(a, b):
    return a + b

print(numbs_3(2, 2))

# Здесь так же сначала работает message, так как он не зависим от порядка. Потом работает cash, передает обернутую
# функцию в error_check, где она проходит обработку ошибок, и та передает обернутую функцию в file_logs_time,
# которая обертывает ее и возвращает к вызову numbs
